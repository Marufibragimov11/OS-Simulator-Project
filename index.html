<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>CPU Scheduling Simulator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #111827;
            color: #e5e7eb;
        }

        h1, h2 {
            text-align: center;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: #1f2937;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: space-between;
        }

        .controls > div {
            margin: 5px 0;
        }

        label {
            display: inline-block;
            margin-right: 5px;
        }

        input[type="number"], select {
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #374151;
            background: #111827;
            color: #e5e7eb;
        }

        button {
            padding: 7px 14px;
            border-radius: 6px;
            border: none;
            background: #2563eb;
            color: #e5e7eb;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #1d4ed8;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: #030712;
        }

        th, td {
            border: 1px solid #374151;
            padding: 6px 8px;
            text-align: center;
        }

        th {
            background: #111827;
        }

        #gantt {
            margin-top: 20px;
            padding: 10px;
            background: #030712;
            border-radius: 8px;
        }

        .gantt-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .gantt-label {
            margin-right: 10px;
            min-width: 60px;
        }

        .gantt-bar {
            display: flex;
            align-items: flex-end;
            flex-grow: 1;
        }

        .gantt-segment {
            min-width: 40px;
            padding: 5px;
            margin-right: 2px;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            background: #10b981; /* зелёный, просто чтобы отличалось */
            color: #000;
            position: relative;
        }

        .gantt-time {
            font-size: 10px;
            position: absolute;
            bottom: -12px;
            left: 2px;
            color: #9ca3af;
        }

        #results {
            margin-top: 20px;
        }

        .footer-note {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 10px;
            text-align: center;
        }

        .small-input {
            width: 70px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>CPU Scheduling Algorithms Simulator</h1>

    <div class="controls">
        <div>
            <label for="numProcesses">Number of processes:</label>
            <input type="number" id="numProcesses" min="1" max="20" value="4">
            <button id="generateTableBtn">Generate table</button>
        </div>
        <div>
            <label for="algorithm">Algorithm:</label>
            <select id="algorithm">
                <option value="fcfs">FCFS</option>
                <option value="sjf">SJF (Non-preemptive)</option>
                <option value="priority">Priority (Non-preemptive)</option>
                <option value="rr">Round Robin</option>
            </select>
        </div>
        <div>
            <label for="quantum">Quantum (RR):</label>
            <input type="number" id="quantum" class="small-input" value="2" min="1">
        </div>
        <div>
            <button id="simulateBtn">Simulate</button>
        </div>
    </div>

    <h2>Processes Input</h2>
    <table id="processTable">
        <thead>
        <tr>
            <th>PID</th>
            <th>Arrival Time</th>
            <th>Burst Time</th>
            <th>Priority (1 = highest)</th>
        </tr>
        </thead>
        <tbody>
        <!-- rows will be generated by JS -->
        </tbody>
    </table>

    <div id="results">
        <h2>Results</h2>
        <div id="gantt">
            <strong>Gantt Chart:</strong>
            <div id="ganttContent"></div>
        </div>
        <div id="resultTableContainer"></div>
        <div id="averages"></div>
    </div>
</div>

<script>
    // -------- Helper: Generate process input table --------
    function generateProcessTable() {
        const num = parseInt(document.getElementById('numProcesses').value, 10);
        const tbody = document.querySelector('#processTable tbody');
        tbody.innerHTML = '';

        for (let i = 0; i < num; i++) {
            const tr = document.createElement('tr');

            const pidCell = document.createElement('td');
            pidCell.textContent = 'P' + (i + 1);
            tr.appendChild(pidCell);

            const arrCell = document.createElement('td');
            const arrInput = document.createElement('input');
            arrInput.type = 'number';
            arrInput.className = 'small-input';
            arrInput.value = i; // just default example
            arrCell.appendChild(arrInput);
            tr.appendChild(arrCell);

            const burstCell = document.createElement('td');
            const burstInput = document.createElement('input');
            burstInput.type = 'number';
            burstInput.className = 'small-input';
            burstInput.value = 3; // default
            burstCell.appendChild(burstInput);
            tr.appendChild(burstCell);

            const prioCell = document.createElement('td');
            const prioInput = document.createElement('input');
            prioInput.type = 'number';
            prioInput.className = 'small-input';
            prioInput.value = 2; // default
            prioCell.appendChild(prioInput);
            tr.appendChild(prioCell);

            tbody.appendChild(tr);
        }
    }

    // Initial table on load
    generateProcessTable();
    document.getElementById('generateTableBtn').addEventListener('click', generateProcessTable);

    // -------- Get data from table --------
    function getProcessesFromTable() {
        const tbody = document.querySelector('#processTable tbody');
        const rows = tbody.querySelectorAll('tr');
        const processes = [];

        rows.forEach((row, index) => {
            const cells = row.querySelectorAll('td');
            const id = index + 1;
            const arrival = parseInt(cells[1].querySelector('input').value, 10) || 0;
            const burst = parseInt(cells[2].querySelector('input').value, 10) || 0;
            const priority = parseInt(cells[3].querySelector('input').value, 10) || 0;

            processes.push({
                id: id,
                arrival: arrival,
                burst: burst,
                remaining: burst,
                priority: priority,
                start: -1,
                finish: 0,
                waiting: 0,
                turnaround: 0
            });
        });

        return processes;
    }

    // -------- FCFS --------
    function simulateFCFS(processes) {
        // Sort by arrival time
        processes.sort((a, b) => a.arrival - b.arrival);

        let time = 0;
        const segments = [];
        let totalWait = 0;
        let totalTAT = 0;

        for (let p of processes) {
            if (time < p.arrival) {
                time = p.arrival;
            }
            p.start = time;
            time += p.burst;
            p.finish = time;

            p.turnaround = p.finish - p.arrival;
            p.waiting = p.turnaround - p.burst;

            totalWait += p.waiting;
            totalTAT += p.turnaround;

            segments.push({ pid: p.id, start: p.start, end: p.finish });
        }

        return {
            processes: processes,
            segments: segments,
            avgWait: totalWait / processes.length,
            avgTAT: totalTAT / processes.length
        };
    }

    // -------- SJF (non-preemptive) --------
    function simulateSJF(processes) {
        let time = Math.min(...processes.map(p => p.arrival));
        let completed = 0;
        const n = processes.length;
        const done = new Array(n).fill(false);
        const segments = [];
        let totalWait = 0;
        let totalTAT = 0;

        while (completed < n) {
            let idx = -1;
            let minBurst = Number.MAX_SAFE_INTEGER;

            for (let i = 0; i < n; i++) {
                const p = processes[i];
                if (!done[i] && p.arrival <= time && p.burst < minBurst) {
                    minBurst = p.burst;
                    idx = i;
                }
            }

            if (idx === -1) {
                time++;
                continue;
            }

            const p = processes[idx];
            p.start = time;
            time += p.burst;
            p.finish = time;

            p.turnaround = p.finish - p.arrival;
            p.waiting = p.turnaround - p.burst;

            totalWait += p.waiting;
            totalTAT += p.turnaround;
            done[idx] = true;
            completed++;

            segments.push({ pid: p.id, start: p.start, end: p.finish });
        }

        return {
            processes: processes,
            segments: segments,
            avgWait: totalWait / n,
            avgTAT: totalTAT / n
        };
    }

    // -------- Priority (non-preemptive) --------
    function simulatePriority(processes) {
        let time = Math.min(...processes.map(p => p.arrival));
        let completed = 0;
        const n = processes.length;
        const done = new Array(n).fill(false);
        const segments = [];
        let totalWait = 0;
        let totalTAT = 0;

        while (completed < n) {
            let idx = -1;
            let bestPrio = Number.MAX_SAFE_INTEGER; // меньший = выше приоритет

            for (let i = 0; i < n; i++) {
                const p = processes[i];
                if (!done[i] && p.arrival <= time && p.priority < bestPrio) {
                    bestPrio = p.priority;
                    idx = i;
                }
            }

            if (idx === -1) {
                time++;
                continue;
            }

            const p = processes[idx];
            p.start = time;
            time += p.burst;
            p.finish = time;

            p.turnaround = p.finish - p.arrival;
            p.waiting = p.turnaround - p.burst;

            totalWait += p.waiting;
            totalTAT += p.turnaround;
            done[idx] = true;
            completed++;

            segments.push({ pid: p.id, start: p.start, end: p.finish });
        }

        return {
            processes: processes,
            segments: segments,
            avgWait: totalWait / n,
            avgTAT: totalTAT / n
        };
    }

    // -------- Round Robin --------
    function simulateRR(processes, quantum) {
        const n = processes.length;
        let time = Math.min(...processes.map(p => p.arrival));
        const segments = [];
        let totalWait = 0;
        let totalTAT = 0;
        let completed = 0;

        // Init remaining and start
        processes.forEach(p => {
            p.remaining = p.burst;
            p.start = -1;
            p.finish = 0;
        });

        const queue = [];
        const inQueue = new Array(n).fill(false);

        // add processes that already arrived
        for (let i = 0; i < n; i++) {
            if (processes[i].arrival <= time && processes[i].remaining > 0 && !inQueue[i]) {
                queue.push(i);
                inQueue[i] = true;
            }
        }

        while (completed < n) {
            if (queue.length === 0) {
                // find next arrival
                let nextArr = null;
                for (let i = 0; i < n; i++) {
                    if (processes[i].remaining > 0) {
                        if (nextArr === null || processes[i].arrival < nextArr) {
                            nextArr = processes[i].arrival;
                        }
                    }
                }
                if (nextArr === null) break;
                if (time < nextArr) time = nextArr;

                for (let i = 0; i < n; i++) {
                    if (processes[i].arrival <= time && processes[i].remaining > 0 && !inQueue[i]) {
                        queue.push(i);
                        inQueue[i] = true;
                    }
                }
                continue;
            }

            const idx = queue.shift();
            inQueue[idx] = false;
            const p = processes[idx];

            if (p.start === -1) {
                p.start = time;
            }

            const execTime = Math.min(quantum, p.remaining);
            const segmentStart = time;
            time += execTime;
            p.remaining -= execTime;

            segments.push({ pid: p.id, start: segmentStart, end: time });

            // Add newly arrived processes
            for (let i = 0; i < n; i++) {
                if (processes[i].arrival <= time && processes[i].remaining > 0 && !inQueue[i] && i !== idx) {
                    queue.push(i);
                    inQueue[i] = true;
                }
            }

            if (p.remaining > 0) {
                queue.push(idx);
                inQueue[idx] = true;
            } else {
                p.finish = time;
                p.turnaround = p.finish - p.arrival;
                p.waiting = p.turnaround - p.burst;
                totalWait += p.waiting;
                totalTAT += p.turnaround;
                completed++;
            }
        }

        return {
            processes: processes,
            segments: segments,
            avgWait: totalWait / n,
            avgTAT: totalTAT / n
        };
    }

    // -------- Render Gantt chart --------
    function renderGantt(segments) {
        const container = document.getElementById('ganttContent');
        container.innerHTML = '';

        if (!segments || segments.length === 0) {
            container.textContent = 'No data.';
            return;
        }

        const row = document.createElement('div');
        row.className = 'gantt-row';

        const label = document.createElement('div');
        label.className = 'gantt-label';
        label.textContent = 'CPU:';
        row.appendChild(label);

        const bar = document.createElement('div');
        bar.className = 'gantt-bar';

        segments.forEach(seg => {
            const div = document.createElement('div');
            div.className = 'gantt-segment';
            div.textContent = 'P' + seg.pid;
            const timeDiv = document.createElement('div');
            timeDiv.className = 'gantt-time';
            timeDiv.textContent = seg.start + '-' + seg.end;
            div.appendChild(timeDiv);
            bar.appendChild(div);
        });

        row.appendChild(bar);
        container.appendChild(row);
    }

    // -------- Render results table --------
    function renderResultTable(processes) {
        const container = document.getElementById('resultTableContainer');
        if (!processes || processes.length === 0) {
            container.innerHTML = '';
            return;
        }

        let html = '<table><thead><tr>';
        html += '<th>PID</th><th>Arrival</th><th>Burst</th><th>Priority</th>';
        html += '<th>Start</th><th>Finish</th><th>Waiting</th><th>Turnaround</th>';
        html += '</tr></thead><tbody>';

        processes.forEach(p => {
            html += `<tr>
                <td>P${p.id}</td>
                <td>${p.arrival}</td>
                <td>${p.burst}</td>
                <td>${p.priority}</td>
                <td>${p.start}</td>
                <td>${p.finish}</td>
                <td>${p.waiting}</td>
                <td>${p.turnaround}</td>
            </tr>`;
        });

        html += '</tbody></table>';
        container.innerHTML = html;
    }

    // -------- Main simulate handler --------
    document.getElementById('simulateBtn').addEventListener('click', function () {
        let processes = getProcessesFromTable();
        const algo = document.getElementById('algorithm').value;
        const quantumVal = parseInt(document.getElementById('quantum').value, 10) || 1;

        // Deep copy to avoid reusing modified objects if user clicks multiple times
        processes = processes.map(p => ({ ...p }));

        let result;
        if (algo === 'fcfs') {
            result = simulateFCFS(processes);
        } else if (algo === 'sjf') {
            result = simulateSJF(processes);
        } else if (algo === 'priority') {
            result = simulatePriority(processes);
        } else if (algo === 'rr') {
            result = simulateRR(processes, quantumVal);
        }

        if (result) {
            renderGantt(result.segments);
            renderResultTable(result.processes);
            document.getElementById('averages').innerHTML =
                `<p>Average waiting time: <strong>${result.avgWait.toFixed(2)}</strong></p>
                 <p>Average turnaround time: <strong>${result.avgTAT.toFixed(2)}</strong></p>`;
        }
    });
</script>
</body>
</html>
</title>
</head>
<body>

</body>
</html>